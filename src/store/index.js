import Vue from 'vue'
import Vuex from 'vuex'

import home from './modules/home'
import animpage from './modules/animpage'
import Web3 from 'web3'
import CyberCarABI from '../plugins/CyberCarABI'
import BigNumber from 'bignumber.js'
import { cyberCarContractAddr } from '../plugins/config'
import { carTypes, colors } from '../plugins/static'

Vue.use(Vuex)

const state = {
  web3: null,
  account: null,
  provider: null,
  signer: null,
  chainId: null,
  carList: []
}
const actions = {
  async connectWallet({ state, commit }, connector) {
    if (connector && connector.isInstalled()) {
      state.provider = await connector.connect()
      if (state.provider) {
        state.web3 = new Web3(state.provider)
        state.cyberCar = new state.web3.eth.Contract(CyberCarABI, cyberCarContractAddr)
        if (connector.name === 'MetaMask') {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })
          state.account = accounts[0]
        } else {
          state.account = state.web3.currentProvider.accounts[0]
        }
      }
      localStorage.setItem('connector', connector.id)
      state.provider.on('disconnect', () => this.dispatch('handleDisconnect'))
    } else {
      return false
    }
    return true
  },
  async disconnectWallet ({ state }) {
    if (
      state.provider &&
      state.provider?.disconnect &&
      typeof state.provider?.disconnect === 'function'
    ) {
      state.provider.disconnect()
    }
    this.dispatch('handleDisconnect')
  },
  async handleDisconnect ({ state }) {
    state.web3 = null
    state.provider = null
    state.account = null
    state.signer = null
    state.chainId = null
    state.cyberCar = null
  },
  async checkBalance({ state }, amount) {
    const balance = await state.web3.eth.getBalance(state.account)
    const amountWei = new BigNumber(state.web3.utils.toWei(amount))
    console.log(new BigNumber(balance).comparedTo(amountWei) === -1)
    if (new BigNumber(balance).comparedTo(amountWei) === -1) {
      return false
    }
    return true
  },
  async startMint({ state }) {
    return await state.cyberCar.methods.startMint().send({
      from: state.account
    })
  },
  /**
   * Returns if only whitelist address can mint.
   */
  async isOnlyWhitelist({ state }) {
    return await state.cyberCar.methods.isOnlyWhitelist().call()
  },
  /**
   * Returns if address is in whitelist.
   */
  async getWhitelist({ state }) {
    return await state.cyberCar.methods.getWhitelist(state.account).call()
  },
  /**
   * Returns if token is mintable.
   */
  async isMintable({ state }) {
    return await state.cyberCar.methods.isMintable().call()
  },
  /**
   * Get information about each car model
   * supply, minted, price.
   */
  async getMintSupply({ state }) {
    let carList = []
    // mode in class 0 must be from 0 to 3.
    const _class0 = 4
    // mode in class 1 must be from 0 to 7.
    const _class1 = 8
    let arr = []
    for (let i = 0; i < _class0; i++) {
      arr.push(await state.cyberCar.methods.getMintSupply(0, i).call())
    }
    for (let i = 0; i < _class1; i++) {
      arr.push(await state.cyberCar.methods.getMintSupply(1, i).call())
    }
    for (let i = 0; i < _class0 + _class1; i++) {
      const car = {
        cid: i,
        class: i < _class0 ? 0 : 1,
        mode: i >= _class0 ? i - _class0 : i,
        name: carTypes[i].name,
        state: carTypes[i].state,
        fee: state.web3.utils.fromWei(arr[i].price, 'ether') + ' ETH',
        rest: arr[i].minted,
        total: arr[i].supply,
        modelUrl: carTypes[i].modelUrl
      }
      carList.push(car)
    }
    return carList
  },
  /**
   * Creates a new token of class and mode. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   *
   * Requirements:
   *
   * - the caller must pay for mint.
   */
  async mint({ state }, params) {
    console.log(params)
    // eslint-disable-next-line new-cap
    const _value = state.web3.utils.toWei(String(params.value), 'ether')
    const gasPrice = await state.web3.eth.getGasPrice()
    const estimateGas = await state.cyberCar.methods.mint(params._class, params._mode).estimateGas({
      from: state.account,
      value: _value
    })
    return await state.cyberCar.methods.mint(params._class, params._mode).send({
      from: state.account,
      gas: estimateGas,
      gasPrice,
      value: _value
    })
  },
  /**
   * Returns cars of owner.
   */
  async getCarsByOwner({ state }) {
    let cars = []
    const carIds = await state.cyberCar.methods.getCarsByOwner(state.account).call()
    for (let i = 0; i < carIds.length; i++) {
      const car = await state.cyberCar.methods.getCar(carIds[i]).call()
      for (let n = 0; n < carTypes.length; n++) {
        console.log(carTypes[n].class)
        console.log(carTypes[n].mode)
        console.log(car.class)
        console.log(car.mode)
        if (parseInt(car.class) === carTypes[n].class && parseInt(car.mode) === carTypes[n].mode) {
          const carObj = {
            cid: carIds[i],
            modelUrl: carTypes[n].modelUrl,
            state: carTypes[n].state,
            name: carTypes[n].name,
            kvs: [
                { lab: 'Acceleration', val: car.acceleration },
                { lab: 'Speed', val: car.speed },
                { lab: 'Control', val: car.control },
                { lab: 'Range', val: car.range },
                { lab: 'Color', val: colors[car.color] }
              ],
            other: carTypes[n].description
          }
          cars.push(carObj)
        }
      }
    }
    return cars
  }
}
const mutations = {}
const store = new Vuex.Store({
  modules: {
    home,
    animpage
  },
  actions,
  state,
  mutations
})

export default store
